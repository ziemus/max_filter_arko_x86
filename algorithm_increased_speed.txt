//ONLY VALUES IN REGISTERS ARE ADDRESED WITHOUT THE *
//ALL DATA SAVED ON THE STACK IS ADDRESED LIKE *variable to portray the use of ebp + offset addressing as in [EBP+8]

//to-do changes in the algorithm:
//exchange offs_fil for incrementing source and destination so that they point to the filtered pixel
//instead of saving the offset to currently checked pixel and adding it each time we check a channes to source, save the address
//of currently checked byte (channel) in a register so that its faster to access
//the following chnages require the use of 3 general-purpose registers 
//now if we save destination pixel under EDI, filtered pixel under ESI
//gdyby zamiast offs_curr brać esi i na początu najwyższej pętli inicjować je wartością addr_box, które się zmienia przecież co zapętlenie najwyższej pętli o 3 (lub w ogóle) 
VOIDPTR offs_fil, offs_box, offs_first, offs_curr, i, j, canal, x_f, y_f, x_c, y_c, next_row_B, width_minus_box;

*offs_fil = *offs_box = *offs_first = *offs_curr = *x_f = *y_f = *x_c = *y_c = 0;
*next_row_B = 3* *width + *padd;
*addr_box = *input_buff //from the stack

while( *y_f < *width )
{
	*addr_first			=	*addr_box; 		//first in row that is
	addr_curr			=	*addr_first;	//currently checked for max value byte

	
	//iter_row doesn't need to be changed for each pixel - only for each line filtered - how do we provide that? 
	*iter_row := 1;	//how many rows the algorithm goes through in current box 
	if ( *y_f < *box )
		*iter_row += *y_f;
	else
		*iter_row += *box;
	
	if (*y_f < *height-*box)
		*iter_row += *box;
	else	
		*iter_row += *height-*y_f-1;

	
		*iter_pxl			=	1; //how many pixels are being checked in each row - THE FILTERED PIXEL
		if( *x_f < *box )			//ADD PIXELS FROM LEFT
			*iter_pxl	+=	*x_f;
		else
			*iter_pxl	+=	*box;
		if(*x_f < *width-*box)		//ADD PIXELS FROM RIGHT
			*iter_pxl	+=	*box;
		else
			*iter_pxl	+=	*width-*x_f-1;
	
	//filtering loop for the box of filtered pixel (x_f,y_f)
	for(*i= *iter_row ; *i ; --*i)
	{
		//check a row of the box
		for(*j = *iter_pxl ; *j ; --*j)
		{
			//check a pixel == 3B
			for(*canal=0 ; *canal < 3 ; ++*canal)
			{
		 		if( *(addr_curr) > *(*first_canal_max-4**canal) ) //assuming max canal values for the box are saved on stack next to each other
					*(*first_canal_max - 4* *canal) = *(addr_curr);  //multiplication by 4 is equivalent to shift right by 2 bits and the second way is much faster
				*addr_curr+=1; //next byte
			}
			//addr_curr was already changed so we go automatically to the next pixel
		}
		//now we've filtered through the whole row, we shall go on to the next row
		*addr_first += *next_row_B;
		addr_curr = *addr_first;
	}
	//now the box has been filtered through so we need to
	//save found max colors under *(dest+*offset_fil)
	
	channel0 to reg, reg to [EDI], edi ++ which is destination byte
	channel1 to reg, reg to [EDI], EDI ++
	channel2 ro reg, reg to [EDI], EDI ++ 
	
	//like that we eliminated the need for offs_fil when saving

	*x_f += 1;
	//*offs_fil += 1; deprecated
	//find new _f and new box coordinates
	if(*x_f == *width) // end of line - in assebly itll be sth like: if != j to elseif_1 ; j loop_beg
	{
		*y_f += 1;
		*x_f = 0;
		//*offs_fil  += *padd;
		//*offs_box	= *offs_fil;	//always set when beginning to filter the 0th pixel of the next row
		//$at this point the box goes to the beginning of the next line only if: *y_f > *box AND *y_f < *height - *box
		//then: *addr_box += 3*(*box + 1) + *padd
		//save 3*(*box + 1) + *padd on the stack to limit muls inside the loop
		//$var *box_next_row
		//$else it goes to the beginning of the current line WHICH IS WHAT 
		//$which is *addr_box -= 3* (*width - *box - 1)
		//$that could be saved onto stack in order to limit the number of multiplies to minimum
		//$var *box_ret_to_row
		*addr_box
	}
	else
	{
		//*offs_box doesn't change until *x_f == *box+1 
		//after and including that its value is incremented by 3 in each loop
		//up until we reach *x_f == *width - *box
		//after and including that value desn't change
		//so it only increases by 3 when (*x_f > *box) && ( *x_f < *width - *box )
		//not to subtrat that each iteration, we may store it on the stack
		if(*x_f > *box)
			//if( *x_f < *width_minus_box) THIS TURNED OUT TO BE INVALID 
			*addr_box += 3;
	}
}
